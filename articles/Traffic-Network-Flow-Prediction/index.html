<!DOCTYPE html>


  <html class="light page-post">


<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Traffic-Network-Flow-Prediction | Hahally&#39;s BLOG</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="paper translation," />
  

  <meta name="description" content="Traffic Network Flow Prediction Using ParallelTraining for Deep Convolutional NeuralNetworks on Spark Cloud  Abstract道路网络中的交通流量是相互交互和相互依存的。 用分析方法描述交通网络流量的动态变化具有挑战性。 在本文中，将使用深度卷积神经网络（DCNN）模型解决交通网络流量预测">
<meta property="og:type" content="article">
<meta property="og:title" content="Traffic-Network-Flow-Prediction">
<meta property="og:url" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/index.html">
<meta property="og:site_name" content="Hahally&#39;s BLOG">
<meta property="og:description" content="Traffic Network Flow Prediction Using ParallelTraining for Deep Convolutional NeuralNetworks on Spark Cloud  Abstract道路网络中的交通流量是相互交互和相互依存的。 用分析方法描述交通网络流量的动态变化具有挑战性。 在本文中，将使用深度卷积神经网络（DCNN）模型解决交通网络流量预测">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210221234502743.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210221234809890.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210221234959933.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222000325167.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222105827613.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222110329834.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222111431596.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222165242874.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222165325532.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222165411159.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222165646807.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222165723988.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222170851525.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222173540467.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222174352908.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222174411353.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222174431003.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222174921653.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222182324651.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222182613529.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222183518350.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222184214461.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222184809248.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222184742766.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222192313448.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222193820080.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222193559417.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222194702280.png">
<meta property="og:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210222200609677.png">
<meta property="article:published_time" content="2021-02-22T12:24:33.000Z">
<meta property="article:modified_time" content="2021-02-22T12:49:41.693Z">
<meta property="article:author" content="hahally">
<meta property="article:tag" content="paper translation">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/image-20210221234502743.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/personal-style.css">

  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Hahally's BLOG" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>


  
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Abstract"><span class="toc-text">Abstract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#INTRODUCTION"><span class="toc-text">INTRODUCTION</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RELATED-WORK"><span class="toc-text">RELATED WORK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TRAFFIC-NETWORK-FLOW-PREDICTION-MODE"><span class="toc-text">TRAFFIC NETWORK FLOW PREDICTION MODE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-DCNN-Prediction-Mode"><span class="toc-text">A.   DCNN Prediction Mode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Training-Sample-Construction"><span class="toc-text">B. Training Sample Construction</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PARALLEL-TRAINING-ON-SPARK-CLOUD"><span class="toc-text">PARALLEL TRAINING ON SPARK CLOUD</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-Problem-Statemen"><span class="toc-text">A. Problem Statemen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Objective-Function"><span class="toc-text">B. Objective Function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-Parallel-Training-Approach"><span class="toc-text">C. Parallel Training Approach</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-Algorithm-Representation"><span class="toc-text">D. Algorithm Representation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-Implementation-on-Spark-Cloud"><span class="toc-text">E. Implementation on Spark Cloud</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXPERIMENTS"><span class="toc-text">EXPERIMENTS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-Dataset-Description"><span class="toc-text">A. Dataset Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Evaluation-Indices-and-Parameter-Configuration"><span class="toc-text">B. Evaluation Indices and Parameter Configuration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-Prediction-Accuracy-and-Generality-Capability"><span class="toc-text">C. Prediction Accuracy and Generality Capability</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-Convergence-and-Efficiency"><span class="toc-text">D. Convergence and Efficiency</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-Tempo–Spatial-Demonstration"><span class="toc-text">E. Tempo–Spatial Demonstration</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CONCLUSION"><span class="toc-text">CONCLUSION</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Traffic-Network-Flow-Prediction" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Traffic-Network-Flow-Prediction</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2021.02.22</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>hahally</span>
        </span>
      

      


      
        <span>
          <i class="icon-comment"></i>
          <a href="https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <blockquote>
<p><a href="https://ieeexplore.ieee.org/document/9007678" target="_blank" rel="noopener">Traffic Network Flow Prediction Using ParallelTraining for Deep Convolutional NeuralNetworks on Spark Cloud</a></p>
</blockquote>
<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>道路网络中的交通流量是相互交互和相互依存的。 用分析方法描述交通网络流量的动态变化具有挑战性。 在本文中，将使用深度卷积神经网络（DCNN）模型解决交通网络流量预测问题。为DCNN模型的并行训练算法开发了理论基础。在Spark Cloud上实现了交通网络流量预测的主从并行计算解决方案。应用交通网络流量数据验证了dcnn预测模型和并行训练算法的有效性。实验结果表明，DCNN交通网络流量预测模型的预测性能优于基于BP神经网络、支持向量回归、径向基函数和决策树回归的典型预测模型。所提出的并行训练方法可以提高训练效率，并通过对数据子集的局部学习获得整个数据集的全局特征。</p>
<p><strong>index-item</strong> : 深度卷积神经网络(DCNNs)、并行训练、Spark云计算、交通大数据、交通网络流量预测</p>
<h3 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h3><p>交通流预测可以引导出行行为，从而缓解道路网络拥堵，提高出行效率，促进交通安全。准确高效的交通流预测是数据驱动智能交通系统的关键部分。</p>
<p>分布在道路网络上的交通流量是相互依赖，相互影响的。 交通网络流量中存在复杂的动态变化，其中道路的拥堵可能直接或间接影响网络中其他道路的交通流量。传统的路段交通流预测方法只考虑了路段的时间序列特征，忽略了路段之间的闭合关系和交互演变。交通网络流量预测模型既要反映每条道路的时间序列演变，又要反映网络流量的空间耦合关系，其中涉及到图像式的数据处理。</p>
<p>深度卷积神经网络(DCNN)模型与其他深度学习模型相比，在提取图像等高维数据特征方面具有优势。它已广泛应用于特征学习，语音识别和医学健康诊断。本文尝试利用 DCNN 模型提取交通网络流量的<em>时空相关动态学</em> 特征。</p>
<p>在处理交通网络流量的大数据进行预测时，在DCNN模型中训练大量参数非常耗时。 云计算在计算资源调度和大数据实时处理方面具有显着优势。特别是最近流行的Spark Cloud 采用了基于内存的计算和主从并行处理的高级架构，突破了某些大数据处理架构（如Hadoop）中的内存限制。此外，它还适用于复杂逻辑算法的实时科学计算。因此，我们尝试为DCNN模型开发一种并行训练方法，该方法适用于采用基于内存的计算和主从并行处理的云计算平台。本文的主要贡献如下:</p>
<ol>
<li>基于自适应梯度下降原理，为DCNN模型开发了并行训练算法的理论基础。它保证了所提出的并行训练算法能够像串行训练算法一样，通过对多个计算节点和各自的数据集进行局部学习，从而学习整个数据集的全局特征，具有良好的收敛性。</li>
<li>将 DCNN 模型应用于交通网络流量预测，以获取交通网络的时空数据特征。该模型首先在 Spark cloud 计算平台上实现，以解决交通网络流量大数据面临的计算复杂性问题。利用实际交通网络工作流数据验证了基于云的并行训练算法的渐近收敛性和加速优势。</li>
</ol>
<p>本文的其余部分安排如下。 第二节总结了相关的研究工作。 第三部分描述了DCNN预测模型的网络结构和训练样本。 在第四部分，我们为DCNN模型开发了并行训练算法的理论基础。 我们还开发了基于Spark Cloud 的实施解决方案。 在第五节中，验证了DCNN模型对交通网络流量预测的预测准确性和通用性。 此外，使用实际交通流数据演示了并行训练算法的收敛性和加速性能。 最后，第六节总结了本文。</p>
<h3 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h3><p>以往的交通流预测工作大致可分为两类: 模型驱动方法和数据驱动方法。模型驱动技术在过去几十年中被广泛应用于交通预测。例如，根据历史交通流的周期性相似性，应用自适应卡尔曼滤波方法[5]预测未来的交通流情况。然而，在这些方法中，交通流的动态波动被假定为线性。此外，它们还可以有效地进行单链路流量的时间序列预测。</p>
<p>数据驱动方法采用间接建模的方法来描述交通流的随机非线性特征。这些方法主要包括神经网络(NN)、支持向量回归(SVR)、径向基核函数(RBF)、决策树回归(DTR)、集成学习回归和极限学习机等。这些方法是数据挖掘的有效工具，可以从一系列数据中提取有用的信息。数据驱动方法用于确定直接模型的结构和参数。开发了一种连续的蚁群优化算法，以加速支持向量回归模型在城际高速公路交通流量预测中的参数选择。通过自适应粒子群优化确定了多层神经网络的最佳结构和参数，提高了流量变量的预测精度。然而，这些研究主要集中在道路时间序列特征的提取上。此外，用浅层结构模型提取的交通流特征也是有限的。</p>
<p>通过模拟人脑的多层感知结构，深度学习可以有效的从高维数据中提取特征信息。它一直被用来处理通信领域的网络流量控制和路由管理。该方法在道路交通流预测领域也得到了应用。通过对交通流数据的重构，将堆叠式编码的 <em>Levenberg-Marquardt</em> 模型和深度信息网络模型应用于挖掘短时交通流固有的时间特征。此外，结合多源数据融合开发了混合深度学习模型方法，以提高业务流预测的准确性和鲁棒性。卷积神经网络模型被用来提取交通网络速度的时间和空间特征。采用 DCNN 模型提取空间特征，采用长短期记忆模型提取交通网速时间序列特征。提出了一种针对 DCNN 模型的随机子空间学习方法，通过寻址不完全交通数据来提高交通流预测的鲁棒性。然而，利用深度学习模型进行交通网络流量预测仍然是一个难题。此外，DCNN 模型在面对大数据时的长时间训练是实时应用中一个尚未解决的问题。针对细胞神经网络模型，提出了一种混合并行训练方法，结合卷积层的数据并行性和完全连接层的模型并行性，并在 GPUs上实现。GPUs 不能灵活地扩展和高效地提供基于内存的计算资源。同时，也没有为并行训练算法的收敛性和稳定性提供理论基础。</p>
<p>云计算为减少训练时间提供了一种可行的解决方案。这是因为处理器、内存和存储器可以灵活地扩展和集群。近年来，apache Spark云计算平台在大数据处理方面取得了令人瞩目的成绩。采用基于内存的计算架构，由一个主计算节点和多个从计算节点组成。Spark cloud已经展示了在大数据科学计算领域应用的潜力，如贝叶斯网络分类、药物发现中的目标预测，以及使用深度学习的移动大数据分析。</p>
<p>本文采用与串行训练算法相同的自适应梯度下降机制，提出了一种并行训练算法。因此，所提出的算法具有理论基础，其中全局特征可以从局部学习中提取出来，即使数据集被分解并提供用于局部学习。采用园区云计算的主从结构实现了交通网络流量预测DCNN模型的并行训练算法。主节点和子节点之间只传输非常有限的数据，如学习参数、局部梯度平方、全局学习率和局部损失函数值。</p>
<h3 id="TRAFFIC-NETWORK-FLOW-PREDICTION-MODE"><a href="#TRAFFIC-NETWORK-FLOW-PREDICTION-MODE" class="headerlink" title="TRAFFIC NETWORK FLOW PREDICTION MODE"></a>TRAFFIC NETWORK FLOW PREDICTION MODE</h3><h4 id="A-DCNN-Prediction-Mode"><a href="#A-DCNN-Prediction-Mode" class="headerlink" title="A.   DCNN Prediction Mode"></a>A.   DCNN Prediction Mode</h4><p>DCNN模型可以捕获交通图像数据样本中丰富的时空特征。特征图中的卷积核连续滑动可以感知不同道路之间交通流的局部相关性。同时，在卷积特征图上滑动的池化窗口被用来进一步保留交通流的基本相关性并减小参数的维数。 最终，具有不同重量和偏置的完全连接的神经进一步重构了交通全局特征。</p>
<p>图1演示了交通网络流量的 DCNN 预测模型的结构。最左边的矩形代表一个可变的流量输入矩阵，紫色的矩形代表一个可变的内核矩阵，绿色的矩形代表一个特征映射矩阵，白色的矩形代表一个池窗口。9层网络结构包括输入层(LI)、卷积层1(Lc1)、池化层1(Lp1)、卷积层2(Lc2)、池化层2(Lp2)、三层全连接层(Lf1、 Lf2、 Lf3)和输出层(Lo)。DCNN 模型的训练目标是建立海量数据样本输入矩阵与输出向量之间的复杂非线性映射关系。在不破坏图像空间结构的前提下，输入图像可以直接输入网络。</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210221234502743.png" alt="image-20210221234502743"></p>
<h4 id="B-Training-Sample-Construction"><a href="#B-Training-Sample-Construction" class="headerlink" title="B. Training Sample Construction"></a>B. Training Sample Construction</h4><p>交通网络结构是静态的，分布式协调流是动态的。类似于面部轮廓上的肌肉运动以形成不同的表情，流量分布和协调表示不同的流量形态。 交通网络流在空间维度上是相互依存和相互关联的。 同时，在时间维度上，每条道路的规则间隔都可能出现某些具有波动的相似交通模式。 因此，在大规模交通网络流量预测中应综合考虑交通网络流量的时空特征。</p>
<p>图2展示了时空训练图像样本的构建过程。 从多个传感器收集的原始数据被汇总到相应的时空序列中，以显示交通网络流量。</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210221234809890.png" alt="image-20210221234809890"></p>
<p>一个二维时空输入矩阵构造为</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210221234959933.png" alt="image-20210221234959933"></p>
<p>其中，$x_{m,k}$ 表示在第k时刻路网第m条链路上的交通流量，d表示时维数据的截断长度。 输入矩阵中的行向量揭示了流在每个链路上的时间序列特征，输入矩阵中的列向量表示流在空间上的耦合特征。M 表示网络中最大的链路数。下文中，变量的下标表示该变量与第n个训练样本相关。训练样本的最大数量定义为N。 如果将输入矩阵中的每个元素都视为图像中的像素，则将大量矩阵类型的数据样本转换为一系列图像，馈入DCNN模型。 该模型提取行和列之间的时空相关性特征。</p>
<p>训练样本的输出表示为：</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222000325167.png" alt="image-20210222000325167"></p>
<p>其中 $y_{m,k+1}$ 是第 $k + 1$ 时刻在第$m$条链路上的输出业务流，$T$表示转置。 训练输入矩阵 $x_n$ 和相应的输出矢量$y_n$形成训练样本$D_n$。 </p>
<h3 id="PARALLEL-TRAINING-ON-SPARK-CLOUD"><a href="#PARALLEL-TRAINING-ON-SPARK-CLOUD" class="headerlink" title="PARALLEL TRAINING ON SPARK CLOUD"></a>PARALLEL TRAINING ON SPARK CLOUD</h3><h4 id="A-Problem-Statemen"><a href="#A-Problem-Statemen" class="headerlink" title="A. Problem Statemen"></a>A. Problem Statemen</h4><p>在交通大数据环境下，要优化的DCNN模型的大量参数需要进行计算密集型任务。 问题是在不降低精度的情况下提高模型参数的训练效率。一种解决方案是将总数据集分解为一些数据子集，并使用多个计算节点以并行方式针对特定于它们的数据子集训练模型参数（称为局部 学习）。 但是，必须协调仅提取数据子集的局部特征的局部学习，以获取整个数据集的全局特征。本节尝试为并行训练方法开发理论基础，并提出基于Spark cloud计算平台的并行训练方法的实现解决方案。 </p>
<h4 id="B-Objective-Function"><a href="#B-Objective-Function" class="headerlink" title="B. Objective Function"></a>B. Objective Function</h4><p>整个数据集D分为R个部分，每个部分定义为$D^r$（r = 1，2，…，R）。因此，数据集D可以表示为$D^{r}$的集合。其中变量中的 r 表示变量相对于第r个数据子集$D^r$，而$N^r$是第 r 个数据子集的大小。</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222105827613.png" alt="image-20210222105827613"></p>
<p>基于(3)中提出的数据分解机制，给出了 DCNN 模型并行训练的目标函数</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222110329834.png" alt="image-20210222110329834"></p>
<p>DCNN 模型训练的目的是最小化目标函数(4) ，并利用 数据集 D 获得权值和偏差。这些权重和偏差称为全局学习参数。对于数据子集，最小均方误差的权值和偏差称为局部学习参数。</p>
<h4 id="C-Parallel-Training-Approach"><a href="#C-Parallel-Training-Approach" class="headerlink" title="C. Parallel Training Approach"></a>C. Parallel Training Approach</h4><p>并行训练方法是通过并行局部学习获得全局学习参数。这包括两个主要的训练阶段：并行特征前向学习和并行误差反向传播。</p>
<p>1) 并行特征正向学习：对于并行特征前向学习，基于相应的数据子集，以并行方式执行各个网络层中的所有激活函数。对于卷积层、池化层和全连通层，分别表示为  $a^{r,l}_{n,j,c}$ 、 $a^{r,l}_{n,j,p}$  、$a^{r,l}_{n,j,f}$</p>
<p>计算方法如下</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222111431596.png" alt="image-20210222111431596"></p>
<p>在 DCNN 模型中，c、 p 和 f 分别表示卷积层、池化层和全连接层；$l $表示第l层，$L$表示层数； $i $表示第 $l $层是卷积或池化层时的第 $i$个输入特征图，或第l层是完全连接层时的第 $i$ 个神经元；当第 $l$ 层是卷积或池化层时，$j$ 表示第$j$个输出特征图；当第$l$层是完全连接层时，$j$表示第$j$个神经元。$w^{r,l}_{j,i,c}$ 和 $b^{r,l}_{j,c}$ 分别是为卷积层的第 $l$ 层中的卷积核矩阵和偏差矩阵。 $N^{l-1}_p$ 表示($l-1$)层中输出特征映射的数量，该层是一个池层。$w^{r,l}_{j,i,f}$和$b^{r,l}_{j,f}$分别是为全连层的第 $l$ 层中的权值和偏置。$N^{l-1}_f$表示($l-1$)层中神经元的数量，该层是一个全连接层。 $σ( )$ 是激活函数，通常选择为整流线性单位，即 $σ(x) = max(0,x)$。* 表示卷积运算。 $H^l_p$ 和 $W^l_p$ 分别是第$l$层中池化窗口的高度和宽度。 $s^l_p$ 是最大池化操作的滑动步幅。</p>
<p>2) 并行误差 BP：基于传统的梯度下降原理[27]，在并行训练过程中确定了并行误差BP阶段的全局学习参数和局部学习参数之间的关系。在步骤 $t$，完全连接的层中的全局学习参数 $w^l_{j,i,f}$ 和 $b^l_{j,f}$ 更新为</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222165242874.png" alt="image-20210222165242874"></p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222165325532.png" alt="image-20210222165325532"></p>
<p>全连通层中的局部权重和偏差表示为</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222165411159.png" alt="image-20210222165411159"></p>
<p>类似地，在步骤t的卷积层中的全局学习参数 $w^l_{j,i,c}$ 和 $b^l_{j,c}$ 迭代计算为</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222165646807.png" alt="image-20210222165646807"></p>
<p>卷积层中的局部权重和偏差表示为</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222165723988.png" alt="image-20210222165723988"></p>
<p>式$(8)-(15)$表明，全局学习参数 $w^l_{j,i,c}$ ， $b^l_{j,c}$ ， $w^l_{j,i,f}$ 和 $b^l_{j,f}$ 分别是局部学习参数 $w^{r,l}_{j,i,c}$ ， $b^{r,l}_{j,c}$  和 $b^{r,l}_{j,f}$ 的平均值$(r = 1,2,…,R)$ 。</p>
<p>在$(8)-(15)$中，相对于数据子集$r$，迭代地计算出误差敏感性 $δ^{r,l}_{n,j,f}$ ， $δ^{r,l}_{n,j,p}$ 和 $δ^{r,l}_{n,j,c}$ ，如下所示：</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222170851525.png" alt="image-20210222170851525"></p>
<p>其中 $N^{l+1}_f$ 是第$(l + 1)$层中的神经元数量，该层是完全连接的层。 $N^{l+1}_c$ 是第$(l + 1)$层（卷积层）中输出特征图的数量。 $rot180(w^{r,l+1}_{\tau,j,c})$ 表示 $w^{r,l+1}_{\tau,j,c}$ 中所有元素翻转 $180°$， $up(δ^{r,l+1}_{n,j,p})$ 表示 $δ^{r,l+1}_{n,j,p}$ 的向上采样操作，以使其大小等于 $z^{r,l}_{n,j,c}$ ， $\bigodot$ 表示元素相乘。</p>
<p>令$θ(ξ) = {w^l_{j,i,c}, b^l_{j,c}, w^l_{j,i,f}, b^l_{j,f}}$表示从步骤 $ξ$的全局权重和偏差置换的列向量。</p>
<p>局部梯度表示为 $g^r(ξ) = \frac{∂J^r}{∂θ(ξ)}=\sum_{n=1}^{N^r}\frac{∂J^r_n}{∂θ(ξ)}.$ </p>
<p>局部梯度平方表示为 $G^r(ξ)=[g^r(ξ)]^Tg^r(ξ) .$</p>
<p>全局自适应学习率可由传统学习率确定，表示为</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222173540467.png" alt="image-20210222173540467"></p>
<p>其中ε是基本学习率，μ是极小的常数。公式$(19)$表示可以从前$(t-1)$个步骤的局部梯度平方$G^r(ξ)(ξ= 1,2,…,t-1)$的累积和中合成$η(t)$ 。</p>
<p>以上推导过程表明，DCNN模型的序列训练和并行训练算法都是相对于整个数据集从统一梯度下降原理出发的，也就是说，并行训练算法的收敛性类似于串行训练算法。 从理论上讲，这保证了整个数据集的全局特征都可以从局部学习中提取出来，而与各自的数据子集无关。</p>
<h4 id="D-Algorithm-Representation"><a href="#D-Algorithm-Representation" class="headerlink" title="D. Algorithm Representation"></a>D. Algorithm Representation</h4><p>算法1中详细说明了基于数据并行化的并行训练过程。主节点负责任务调度，资源分配，数据聚合以及从节点之间的数据分配。 同时，从节点主要承担特定的计算任务。 第1行和第2行初始化主节点和从节点。 第4行描述了主节点广播的全局参数。 第5-15行说明从属节点中的并行特征学习，第16–28行表示从属节点中的并行误差BP。 然后，从节点反馈局部学习参数，局部梯度平方和第29行的局部损失函数。主节点通过第30行聚合全局参数、学习速率和损失函数。</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222174352908.png" alt="image-20210222174352908"></p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222174411353.png" alt="image-20210222174411353"></p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222174431003.png" alt="image-20210222174431003"></p>
<h4 id="E-Implementation-on-Spark-Cloud"><a href="#E-Implementation-on-Spark-Cloud" class="headerlink" title="E. Implementation on Spark Cloud"></a>E. Implementation on Spark Cloud</h4><p>DCNN模型的拟议并行训练方法已部署在Spark云上。 如图3所示，Spark云计算采用典型的主从结构，具有一个主节点和多个从节点。 红色箭头表示全局数据广播，而主节点和从节点之间的蓝色箭头表示本地数据收集。 资源管理器节点用于管理，调度和监视集群中节点的运行状态。数据并行性:将存储在Hadoop HDFS (distributed file system)中的流量网络流的大数据通过Spark应用程序编程接口进行分区。由此产生的交通数据分区被构造成弹性分布式数据集，并分布到相应的从节点上。并行训练：算法1中描述的并行训练过程适用于Spark云中的MapReduce编程系统。在迭代学习过程中，局部数据更新被视为Map阶段，而全局数据更新则在Reduce阶段实现。在Map阶段，所有从属节点以并行方式执行任务，尽管它们在不同的数据分区上。在Reduce阶段，主节点更新全局学习参数和学习率。然后，主节点将这些更新后的全局数据重新分配给每个从节点，作为后续迭代过程的初始值。该过程继续进行，直到达到最大迭代次数或训练精度条件。</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222174921653.png" alt="image-20210222174921653"></p>
<p>在Spark云上并行训练交通网络流量预测模型的部署步骤如下:</p>
<p>1) 交通流训练数据集被提交到Spark cloud，并存储在所有slave nodes 中的HDFS中</p>
<p>2) 将DCNN预测模型的训练代码提交给Spark cloud</p>
<p>3) 计算节点信息是根据程序代码计算和配置的，程序代码包括执行器的数量、内存大小和每个执行器的CPU核数</p>
<p>4) 任务请求被提交给资源管理器(RM)，然后，RM 部署相应的计算节点，并在主节点和多个从节点之间建立连接</p>
<p>5) 主节点初始化网络结构和参数，并将模型副本分发给从节点</p>
<p>6) 主节点将全局学习参数和学习率分配给从节点</p>
<p>7) 从属节点以并行方式计算局部梯度、更新局部学习参数、梯度平方和损失函数，尽管在不同的数据分区上</p>
<p>8) 来自从节点的局部学习参数和梯度平方被累积以获取全局学习参数和主节点上的学习速率</p>
<p>9) 如果训练过程满足终止条件，则返回预测模型和预测结果。否则，转到步骤(6）</p>
<h3 id="EXPERIMENTS"><a href="#EXPERIMENTS" class="headerlink" title="EXPERIMENTS"></a>EXPERIMENTS</h3><h4 id="A-Dataset-Description"><a href="#A-Dataset-Description" class="headerlink" title="A. Dataset Description"></a>A. Dataset Description</h4><p>利用美国加州运输部交通绩效评估系统(PeMS)数据库中的路网交通流数据，通过并行训练对DCNN模型的预测性能进行评估。所需数据已从PeMS网站下载。道路网络中的日随机交通流呈现出相同的波动模式，反映了相对稳定的行驶需求和规则的交通流传播。这是一个很好的例子。可以观察到，一周中的同一天的交通流量呈现出一种与时间有关的周期性可重复性，并且受到道路的干扰。训练数据嵌入了高速公路上交通流量的时间序列波动特征及其与时空的耦合关系。 高速公路之间的交通流量。 DCNN模型用于捕获交通网络流的动态特征。</p>
<p>图4(a)示出加州高速公路交通网络结构，包括12条高速公路: $SR17-S,SR17-N,SR87-N,SR87-S,US101-N,US101-S,I280-N,I280-S,I680-N,I680-S,I880-N$以及$I880-S$ 。每30分钟收集一次交通数据，每5分钟收集一次来自39000多个探测器的数据，这些检测器分布在加州所有主要大城市的高速公路系统中。在本研究中，2016年的前9个月，从指定的12条高速公路收集的交通网络流量数据应用于实验。使用前8个月的数据作为训练数据集，剩余1个月的数据作为测试数据集。在Spark云计算平台上，将整个训练数据集分解为多个数据集，并分布到不同的计算节点上。通过多节点局部学习与对应数据子集的协调，学习整个数据集的全局数据特征。利用剩余的测试数据验证采用并行训练的DCNN模型是否具有提取稳定随机交通流模式的能力。将预测时间间隔定义为5、15、30、45和60min，将模型中的原始交通流数据聚合为相应的时间间隔。训练数据集和测试数据集分为输入数据和输出数据两部分。DCNN模型的输入和输出数据分别由(1)和式(2)构建。4(b)显示2016年5月9日的交通图像样本。红色区域代表拥堵，绿色区域代表交通顺畅。</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222182324651.png" alt="image-20210222182324651"></p>
<h4 id="B-Evaluation-Indices-and-Parameter-Configuration"><a href="#B-Evaluation-Indices-and-Parameter-Configuration" class="headerlink" title="B. Evaluation Indices and Parameter Configuration"></a>B. Evaluation Indices and Parameter Configuration</h4><p>采用平均绝对误差（MAE）、平均相对误差（MRE）和均方根误差（RMSE）三个综合评价指标评价交通流预测模型的预测精度。计算方式如下：</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222182613529.png" alt="image-20210222182613529"></p>
<p>其中$\hat{y}^m_n$是第m个链路上的预测流量，$y^m_n$是第m个链路上的观测流量，$M$是测试数据样本的输出维度，而$N_t$是测试数据样本的数量。为了衡量路网中不同路段之间的预测精度，本文提出了一种性能指标，即预测精度指标的累积比例（CP）。以MRE索引为例进行说明。将所有链路的MREs按升序排序。最小值和最大值分别表示为$MRE^{min},MRE^{max}$。在链路上的MRE准确性的示例被定义为MREs。CP表示为</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222183518350.png" alt="image-20210222183518350"></p>
<p>其中$N_{MRE_S}$是$MRE_s$不大于$MRE_s$的链路数。 显然，当$MRE_s = MRE^{max}$时，$CP(MRE_s)= 1$。 CP与MRE的离散点曲线反映了随着MRE的增加，链路部分的累积分布。通过使用Spark云上不同数量的节点，加速Speedup用于评估并行训练算法的时间效率。 计算方式如下：</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222184214461.png" alt="image-20210222184214461"></p>
<p>其中$T_s$是具有指定数据集的单台机器上DCNN模型的训练时间，而$T_p$是使用同一数据集的并行训练的训练时间。</p>
<p>DCNN模型的网络结构设计和参数调整对于预测准确性至关重要。 在这项研究中，我们通过大量实验获得了针对交通网络流量预测的不同预测间隔的适当模型结构。 这些在表$I$中列出。DCNN模型的所有模拟都部署在阿里云Elastic MapReduce计算平台上。</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222184809248.png" alt="image-20210222184809248"></p>
<h4 id="C-Prediction-Accuracy-and-Generality-Capability"><a href="#C-Prediction-Accuracy-and-Generality-Capability" class="headerlink" title="C. Prediction Accuracy and Generality Capability"></a>C. Prediction Accuracy and Generality Capability</h4><p>为了充分说明基于 DCNN 模型的交通流预测在预测精度和通用性方面的优势，我们选择了其他4种交通流预测模型作为比较对象: BP 神经网络、 RBF、 SVR 和 DTR。</p>
<p>如表 $II$所示，对于不同的预测区间，DCNN模型的 MAE、 MRE 和 RMSE 明显小于其他预测模型。在 MRE 指标方面，对于不同的流量网络工作流预测任务，DCNN 模型的预测准确率一般在90% 以上。具体来说，对于5min 的流量预测，DCNN模型的预测精度比 BP、 RBF、 SVR 和 DTR 模型分别提高了4.51% 、7.24% 、10.15% 和6.27% 。对于15分钟交通流量预测，DCNN模型的预测精度分别比 BP、 RBF、 SVR 和 DTR 模型分别高5.26% 、7.17% 、5.23% 和6.07% 。对于30分钟、45分钟和60分钟的交通流量预测，DCNN 模型的预测精度一般比其他模型的预测精度高3.29-9.85%。DCNN 模型的 MAE和 RMSE 平均分别比 BP、 RBF、 SVR 和 DTR 预测模型的 MAEs和 RMSE 低7.49-40.07% 和4.38-38.22% 。这些结果表明，利用 DCNN 模型从海量交通数据中分离出时空特征，可以显著提高预测精度。与 BP、 RBF、 SVR 和 DTR 模型相比，DCNN 模型具有独特的卷积过程，能够处理网络流图像数据，在不丢失空间结构信息的情况下提取时间序列特征。此外，多层网络结构可以平衡隐藏在流量大数据集中的海量信息的学习。并行训练方法能够快速、全局地学习交通网络流的基本特征。</p>
<p>泛化能力是衡量DCNN模型对不同交通场景适应性程度的重要指标。通过一系列实验，将DCNN模型与其它四种典型预测模型进行比较，评价了DCNN模型在不同预测区间的通用性。表$II$表明，DCNN模型的预测精度在90.03%到92.16%之间。这说明DCNN模型对不同预测区间的适应能力较强。然而，BP和SVR模型的MRE随着预测间隔的变化而迅速波动。这两个模型对预测间隔的变化很敏感，这意味着这两个模型的泛化能力很低。对于不同的预测区间，RBF和DTR模型的预测精度相对稳定。当时间间隔较大时，该模型的交通流预测精度略有下降。这是因为模型提取的有效特征会随着数据量的减少而减少。图5显示了不同预测间隔下CP与MRE的关系曲线。对于5、15、30、45和60分钟的预测间隔，超过90％，85％，60％，80％以及70％的高速公路链接上，DCNN模型的MRE预测精度超过90％。 在不同的预测间隔下，DCNN模型的CP与MRE的曲线都位于其他预测模型的CP与MRE的曲线的左上侧。 这表明不同高速公路个体之间DCNN模型的预测准确性有所提高。</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222184742766.png" alt="image-20210222184742766"></p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222192313448.png" alt="image-20210222192313448"></p>
<h4 id="D-Convergence-and-Efficiency"><a href="#D-Convergence-and-Efficiency" class="headerlink" title="D. Convergence and Efficiency"></a>D. Convergence and Efficiency</h4><p>表$III$中显示了Spark云上单机和多节点计算环境之间的类似预测性能。 显然，使用一台机器的预测精度为90.18％，而在相同的训练时期，使用Spark云上不同数量的计算节点的精度在91.46-92.69％之间。图6（a）描述了单机训练和使用不同计算节点的并行训练的相似收敛过程。图6（b）中，从迭代步骤100开始开始，我们可以进一步观察到损失函数随着训练时间的增加而减少。 它们最终在Spark云上的单机训练和分布式并行训练中收敛到几乎相同的阈值。 在不同的计算节点之间，预测精度和收敛过程的细微差异是由训练开始时随机函数产生的初始权重和偏差引起的。 尽管如此，由于理论上有保证的训练算法，训练过程最终收敛到几乎相同的阈值。表$III$和图6说明并行训练与单机训练训练结果的收敛性一致性。这与第四节的理论分析是一致的。</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222193820080.png" alt="image-20210222193820080"></p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222193559417.png" alt="image-20210222193559417"></p>
<p>并行计算方法取得了良好的计算效率，如图7所示。与单机计算环境相比，随着图7中左y轴的增加，Spark云上计算节点的数量增加，计算时间逐渐减少。大量的训练样本分布在多个从节点之间，可以减少计算量。 此外，Spark云计算将训练过程的中间结果捕获到内存中。 这进一步提高了迭代数据处理的计算效率。如图7所示，在右y轴的基础上，随着节点数量的增加，加速比在早期阶段近似线性地增加。 但是，当后续阶段节点数增加到一定规模时，节点间的数据传输增加了通信开销，云上的资源调度和进程管理增加了并行管理开销。 这相应地影响了加速比并使其线性度降低。</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222194702280.png" alt="image-20210222194702280"></p>
<h4 id="E-Tempo–Spatial-Demonstration"><a href="#E-Tempo–Spatial-Demonstration" class="headerlink" title="E. Tempo–Spatial Demonstration"></a>E. Tempo–Spatial Demonstration</h4><p>采用基于DCNN的交通网络流量预测模型，获取高速公路交通流量的时间序列特征和空间耦合特征。图8展示了2016年9月6日至14日5分钟间隔交通网络流量的观测和预测结果。图8(a)描述每5分钟在高速公路上观测一次的交通流量，分别用1-12编号。图8(b)表示高速公路上每5分钟的交通流量预测结果。从空间维度上，图8中，预测结果表明，在时间-空间动态中，流量形态与实际流量极为相似。同时，图8表明交通流量的周期性变化趋势和随机波动已经被 DCNN 模型沿时间维度近似捕获。同时，图8表明交通流量的周期性变化趋势和随机波动已经被 DCNN 模型沿时间维度近似捕获。</p>
<p><img src="/articles/Traffic-Network-Flow-Prediction/image-20210222200609677.png" alt="image-20210222200609677"></p>
<p>总体而言，基于DCNN的Spark云并行训练算法的交通网络流量预测模型具有明显的优势。通过对相应数据子集中分布计算节点的局部学习，显示了良好的全局特征学习能力和学习收敛的理论基础。与DCNN模型的串行学习算法相比，在Spark云上并行训练算法的实施提高了实时参数学习效率。</p>
<h3 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h3><p>本文提出了一种面向交通大数据处理的基于 DCNN 模型的交通网络流量预测方法。该算法结合了参数化网络模型的并行训练算法和计算机网络模型的并行训练算法。考虑到数据分解不会削弱对交通网络流全局特征的捕获，而是有利于计算复杂度的处理，为保证并行训练算法提供了理论基础。实验结果表明，该方法在预测精度和通用性方面优于 BP、 RBF、 SVR 和 DTR 模型。该并行训练算法既能提取不同路段交通流的时间序列特征，又能提取路段间交通流的空间耦合特征。全局特征可以通过分布式数据集的局部学习以并行方式重构。提出的并行训练算法提高了交通网络流量预测的计算效率。Spark云计算平台提供了灵活的机制来扩展计算资源和能力。这使得该实现方案适用于全网流量预测。基于Spark云计算的交通网络流量预测可以帮助交通指挥中心做出及时的控制决策，引导出行者选择最优路径规避拥堵。这是留给将来研究的。</p>

    
  </div>

     <div id="gitalk-container"></div>
     

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: 'ee979f0e6d62adec6722',
  clientSecret: 'af19f8bdcad202e18bd00c4b65105281776a7570',
  repo: 'hahally.github.io',
  owner: 'hahally',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: md5(location.pathname),
  admin: ['hahally'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->




</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持hahally</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/articles/%E4%B9%9D%E5%93%81%E7%82%BC%E4%B8%B9%E5%B8%88/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/articles/GMAN/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>



  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'https://hahally.github.io/articles/Traffic-Network-Flow-Prediction/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: 'ee979f0e6d62adec6722',
  clientSecret: 'af19f8bdcad202e18bd00c4b65105281776a7570',
  repo: 'hahally.github.io',
  owner: 'hahally',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: md5(location.pathname),
  admin: ['hahally'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
